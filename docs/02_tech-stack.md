# 技術スタック

## 採用技術とその理由

### フロントエンド

- **Next.js 16 (App Router)**
  - 最新のReact機能（Server Components等）を活用し、パフォーマンスとSEO（将来的な公開を見据え）を最適化するため。
  - ルーティングとBFF機能の統合運用が可能。
- **React 19 / TypeScript 5**
  - 型安全性と最新のエコシステムを活用し、保守性の高いコードベースを維持するため。
- **Tailwind CSS v4**
  - ビルドパフォーマンスが高く、モダンなCSS機能を活用して迅速にスタイリングを行うため。
- **shadcn/ui + Radix UI + lucide-react**
  - アクセシビリティに配慮しつつ、美しく一貫性のあるUIを高速に構築するため。

### データアクセス・通信

- **Relay (React Relay + Relay Compiler)**
  - データ要件をコンポーネントとコロケーション（配置）することで、Over-fetching/Under-fetchingを防ぐ。
  - コンパイル時の静的解析により、クエリの正当性を保証する。
- **GraphQL**
  - 柔軟なデータ取得と、スキーマによる型安全な契約を提供するため。

### バックエンド・DB

- **Hasura GraphQL Engine**
  - バックエンドの実装工数を大幅に削減し、PostgreSQLスキーマから即座にCRUD APIを生成するため。
  - 基本的なCRUD要件はコードを書かずに設定のみで完結させる。
- **PostgreSQL 16**
  - 堅牢なRDBMSとしてリレーショナルデータの整合性を担保するため。
- **Prisma**
  - データベーススキーマの定義とマイグレーション管理を行うため。
  - SQLを直接書くよりも宣言的で可読性が高いSchema定義を利用。

### 開発環境

- **pnpm**: 高速でディスク効率の良いパッケージマネージャー。
- **Docker Compose**: DBとHasuraを含むローカル開発環境の再現性を確保。

## 各レイヤーの責務

| レイヤー        | 技術               | 責務                                                                                                                |
| --------------- | ------------------ | ------------------------------------------------------------------------------------------------------------------- |
| **Client**      | Next.js / React    | UI描画、ユーザー入力、Relayを通じたデータ要求の定義。ロジックは最小限に。                                           |
| **BFF**         | Next.js API Routes | クライアントからのリクエストを受け、認証情報を付与してHasuraへプロキシする。独自ロジック（CSVインポート等）の実行。 |
| **Gateway**     | Hasura             | GraphQLリクエストの解決、DBクエリへの変換、基本的な認可（今回は簡易）。                                             |
| **Database**    | PostgreSQL         | データの永続化、整合性の担保（外部キー、ユニーク制約）。                                                            |
| **Infra/Tools** | Prisma             | スキーマ定義の管理、マイグレーションの実行。アプリケーションコードからは直接呼ばない。                              |

## Relay + Hasura構成の設計意図

この構成の最大の意図は、**「フロントエンドエンジニアがデータモデルを直接操作感覚で扱えるようにしつつ、堅牢性を維持すること」**です。

- **開発効率**: HasuraによりAPI実装が不要になるため、フロントエンド開発に集中できます。
- **パフォーマンス**: Relayの高度なキャッシュ戦略と最適化されたGraphQLクエリにより、複雑なリレーションデータも効率的に取得できます。
- **安全性**: Relay Compilerがビルド時にクエリの整合性をチェックするため、実行時エラーを大幅に削減できます。

## トレードオフ

- **学習コスト**: Relayの概念（Fragment、Compiler、Store）は習得難易度が比較的高く、初期の学習コストがかかります。
- **柔軟性の制限**: Hasuraの自動生成APIに依存するため、非常に複雑なビジネスロジックや特殊なクエリが必要な場合、HasuraのAction機能やRemote Schemaへの拡張が必要となり、構成が複雑になる可能性があります（本プロジェクトのスコープ内では許容範囲）。
- **ビルドステップの増加**: Relay CompilerやGraphQL Code Generatorなど、開発時に実行すべき生成プロセスが増えます（`pnpm codegen`等でカプセル化して対応）。
